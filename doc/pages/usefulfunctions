
@page usefullFunctions Useful Functions
@tableofcontents

----


This page is dedicated to the useful Functions for the volSacalarField

### General Information (Miguel)

The useful functions created for the volField Class aim at providing a set of utilities to manipulate objects of the class and/or create new objects based on previously created objects of the class.That will include for example calculating the maximum and minimum of a field, the shift and scale of a field, the projection of a vector, and the tensor invariants. 

----
### Max and Min from a Field (Miguel)
For operations like shift field, the shift can be performed with the maximum or minimum value of the field

The calculation of the minimum or maximum value of the field depends on the type of field:

* **Scalar fields**: are the maximum or minimum of the field
* **Vector fields**: are the maximum or minimum of the vector magnitude
* **Tensor and Symmetric Tensor fields**: are the maximum or minimum of the second invariant of the tensor


----
### Shift Field (Paulo)
line1

line2

line3

Shift the field with a constant (scalar, vector, symTensor and tensor)
The constant is the
minimum value
maximum value


----
### Scale Field (Paulo)
line1

line2

line3

Scale the field with a constant scalar (same documentation as Shift)


----

### Vector Field related (Karinate)
// G5 - Contribution
//To compute the magnitude of a vectorField
// define new functions in vectorOperations.h
inline double magVector(const vectorField& v1) {

for (unsigned int i=0; i < v1.size(); i++) {
       double sum = (pow(v1[i][0],2)
                    +pow(v1[i][1],2)
                    +pow(v1[i][2],2));
    double result= sqrt(sum);
              return result;
  } 
   }

// G5 - Contribution
// To compute a scalarField to store the magnitude of the vectorField
// define new functions in vectorOperations.h
template <typename vectorType>
scalarField volField<vectorType>::magVector()
{
  vector3 v1;
  volField<scalarField> result;
if (typeid(internalField).hash_code()==typeid(v1).hash_code() {
    string magFieldFname="magof"+fieldName_;

       result.fieldName_=magFieldFname;
       result.runTime_=runTime_;

for(unsigned int i= 0; i < internalField.size(); i++) {
    result.internalField.push_back(mag(internalField[i]));
 }

for(unsigned int i = 0; i < mesh_.nPatches_; i++){
 for(unsigned int i = 0; i < mesh_.nPatches_; i++){
       result.boundaryField_[i].type = "fixedValue";
       result.boundaryField_[i].valImposed = true;
      for(unsigned int j = 0; j < result.boundaryField_[i].fieldValue.size(); j++){
         result.boundaryField_[i].fieldValue.push_back (mag(boundaryField_[i].fieldValue[j])); 
      }
    }
   }
  }
else
 {
cout:: << "Error: Function volField<vectorType>::magVector called for a non vector Field";
  }
return result;

### Tensor Field related (Mohamed)
1- Create a vector field with component of the tensor in one direction

The component of the tensor in one direction is obtained by multiplying the transpose of the tensor by the unity vector in that direction. As for example for the direction of x, the mathematical operation takes the following form as shown in Eq(1): 

\begin{equation}
\begin{pmatrix}
\sigma _{xx} & \sigma _{xy} & \sigma _{xz}\\ 
\newline
\sigma _{yx}& \sigma _{yy} &\sigma _{yz} \\ 
\newline
\sigma _{zx}& \sigma _{zy} & \sigma _{zz}\ 
\end{pmatrix}^{t}\begin{pmatrix}
1\\ 
\newline
0\\ 
\newline
0
\end{pmatrix}
\end{equation}

That could be achieved in the CrheoLab using the function projectTensorField, where a general vector direction is avaiable.


2- Create a scalarField with the Tensor Invariants (I1, I2 and I3)

The first tensor invariant (I1) is calculated as the trace of the tensor (T) i.e. the summation of the main diagonal. The second tensor invariant (I2) is calculated as half the extraction of the square of the tensorâ€™s trace and the trace of the square of the tensor. The third tensor invariant (I3) is calculated as the determine of the tensor. The mathematical description is as shown in Eqs(2)-(4) for I1, I2, and I3 respectively:

\begin{equation}
I1 =  tr\left [ T \right ] = \sigma _{xx} +\sigma _{yy} +\sigma _{zz}
\end{equation}

\begin{equation}
I2 = \frac{1}{2} {\left [ \left [ \sigma _{xx} +\sigma _{yy} +\sigma _{zz}  \right ]^{2} -tr\left [ T .T \right ]\right ]= \sigma _{xx}\sigma _{yy}+\sigma _{yy}\sigma _{zz}+\sigma _{xx}\sigma _{zz}-\sigma _{xy}\sigma _{yx}-\sigma _{yz}\sigma _{zy}-\sigma _{xz}\sigma _{zx}}
\end{equation}

\begin{equation}
I3 = \left | T \right | =\sigma _{xx} \left [\sigma _{yy}\sigma _{zz}-\sigma _{yz}\sigma _{zy}  \right ] - \sigma _{xy} \left [ \sigma _{yx}\sigma _{zz}-\sigma _{yz}\sigma _{zx} \right ]+\sigma _{xz}\left [ \sigma _{yx}\sigma _{zy}-\sigma _{yy}\sigma _{zx} \right ]
\end{equation}

In the CrheoLab, they are calculated using the functions I1, I2, and I3 respectively.

----
